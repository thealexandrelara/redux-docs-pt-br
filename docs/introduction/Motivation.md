# Motivação

A medida que os requisitos para aplicativos de página única do JavaScript se tornaram cada vez mais complicados, ** nosso código deve gerenciar mais estados do que nunca **. Esse estado pode incluir respostas do servidor e dados em cache, bem como dados criados localmente e que ainda não foram persistidos no servidor. O estado da UI (interface de usuário) também está aumentando em complexidade, já que precisamos gerenciar rotas ativas, guias selecionadas, spinners, controles de paginação e assim por diante.

Gerenciar esse estado em constante mudança é difícil. Se um model puder atualizar outro model, então a view poderá atualizar um model, que atualizará outro model, e isso, por sua vez, poderá fazer com que outra view seja atualizada. Em algum momento, você não entende mais o que acontece no seu aplicativo, pois você perdeu o controle do estado sobre quando, por que e como. \*\* Quando um sistema é opaco e não-determinístico, é difícil reproduzir erros ou adicionar novos recursos.

Como se isso não bastasse, considere os ** novos requisitos se tornando comuns no desenvolvimento de produtos front-end **. Como desenvolvedores, é esperado que lidemos com atualizações otimistas, renderização do lado do servidor, buscando dados antes de realizar transições de rotas e assim por diante. Nós nos encontramos tentando administrar uma complexidade com a qual nunca tivemos que lidar antes, e inevitavelmente fazemos a pergunta: [é hora de desistir?](http://www.quirksmode.org/blog/archives/2015/07/stop_pushing_th.html) A resposta é _não_.

Essa complexidade é difícil de lidar, pois ** estamos misturando dois conceitos ** que são muito difíceis para a mente humana pensar: ** mutação e assincronismo. ** Eu os chamo de [Mentos e Coca-Cola] (https: // en.wikipedia.org/wiki/Diet_Coke_and_Mentos_eruption). Ambos podem ser ótimos na separação, mas juntos eles criam uma bagunça. Bibliotecas como [React](http://facebook.github.io/react) tentam resolver esse problema na camada de visualização removendo tanto a assíncronicidade quanto a manipulação direta de DOM. No entanto, gerenciar o estado de seus dados é sua responsabilidade. É aqui que o Redux entra.

Seguindo as etapas do [Flux](http://facebook.github.io/flux), [CQRS](http://martinfowler.com/bliki/CQRS.html), e [Event Sourcing](http://martinfowler.com/eaaDev/EventSourcing.html), **Redux tenta fazer as mutações de estado previsíveis** impondo certas restrições sobre como e quando as atualizações podem acontecer. Essas restrições estão refletidas nos [três princípios](ThreePrinciples.md) do Redux.
